<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_player</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>obj_Enemy_Base</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>604</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>1</exetype>
        <functionname>action_inherited</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Initialize

// New instance variables

// If we have LOS to player in the current step.
PlayerLOS = false;
// If we had LOS to player in the last step.
PrevPlayerLOS = false;
// Shoot flag.
CanShoot = false;
// Min time between shots.
ShotCooldown = 60;
// Number of frames to look ahead when firing 'reaction'
//  shot when first detecting player.
BlindFrameEstimate = 10;
// Projectile to fire.
Projectile = obj_Arrow;

// Overrides
DetectionRadius = 500;
State = "Default";

// Initial timers
alarm[5] = ShotCooldown;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// CanShoot
CanShoot = true;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>604</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>1</exetype>
        <functionname>action_inherited</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Check LOS to player

// Push back LOS flag from last step.
PrevPlayerLOS = PlayerLOS;

// If we have line of sight
if (collision_line(x, y, global.MyInst.x, global.MyInst.y, obj_Wall, true, false) == noone)
{
    PlayerLOS = true;
}
else
{
    PlayerLOS = false;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>604</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>1</exetype>
        <functionname>action_inherited</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Shoot
if (CanShoot &amp;&amp; PlayerLOS &amp;&amp; PlayerDetected)
{
    // Get the player instance for reference and create an arrow.
    var player_info = instance_nearest(x, y, obj_Dwarf);
    var projectile = instance_create(x, y, Projectile);
    
    // Estimate the number of game updates (steps) it will take for the arrow to get to the player.
    var num_frames_til_impact = distance_to_point(player_info.x, player_info.y) / projectile.speed;
    
    // Find position the player will be at at the estimated point the arrow will contact them.
    var player_next_x = player_info.x + num_frames_til_impact * player_info.hspeed;
    var player_next_y = player_info.y + num_frames_til_impact * player_info.vspeed;
    
    // Set the arrow direction and sprite orientation.  Set the projectile owner as well to this instance.
    
    // If player is just detected, we fire blindly by making a 'guess' at the number of frames til impact.
    if (PrevPlayerLOS != PlayerLOS)
    {
         projectile.direction = point_direction(projectile.x, projectile.y, player_info.x + player_info.hspeed * BlindFrameEstimate, 
                                                player_info.y + player_info.vspeed * BlindFrameEstimate);
    }
    // Otherwise use the predicted movement.
    else
    {
        // If the shot is invalid, just shoot at where the player is.
        if (collision_line(x, y, player_next_x, player_next_y, obj_Wall, false, false) != noone)
        {
            player_next_x = player_info.x;
            player_next_y = player_info.y;
        }
        
        projectile.direction = point_direction(projectile.x, projectile.y, player_next_x, player_next_y);
    }
   
    // Orient the sprite properly and assign ownership of the projectile to this enemy.
    projectile.image_angle = projectile.direction;
    projectile.Owner = id;
    
    // Reset shot throttling variables.
    CanShoot = false;
    alarm[5] = ShotCooldown;
    
    // Set state to something to prevent wandering while shooting
    //  and stop current movement.
    State = "Shooting";
    speed = 0;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>16,32</point>
    <point>16,16</point>
  </PhysicsShapePoints>
</object>
